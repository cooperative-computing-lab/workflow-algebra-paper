#! /usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
CWD

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.058';
  
  use Carp ();
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent> — ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers> — A hashref of default headers to apply to requests
  #pod * C<local_address> — The local IP address to bind to
  #pod * C<keep_alive> — Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size> — Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, responses larger than this will return an
  #pod   exception.
  #pod * C<http_proxy> — URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}> — if set)
  #pod * C<https_proxy> — URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}> — if set)
  #pod * C<proxy> — URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}> — if set)
  #pod * C<no_proxy> — List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> —)
  #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, an exception is thrown.
  #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
  #pod   certificate of an C<https> — connection (default is false)
  #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
  #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  #pod content field in the response will contain the text of the exception.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  Also, if any connection-relevant
  #pod attributes are modified, or if the process ID or thread ID change, the
  #pod persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
  
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> —
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> —
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> —
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> —
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> —
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances).
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> —
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> —
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> —
  #pod     The HTTP status code of the response
  #pod * C<reason> —
  #pod     The response phrase returned by the server
  #pod * C<content> —
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> —
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an exception during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the exception.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      # If a socket exists...
      if ($self->{handle} && $self->{handle}{fh}) {
          my $socket = $self->{handle}{fh};
  
          # ...and is connected, return the peer host and port.
          if ($socket->connected) {
              return wantarray
                  ? ($socket->peerhost, $socket->peerport)
                  : join(':', $socket->peerhost, $socket->peerport);
          }
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . $class->VERSION;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.058
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers> — A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address> — The local IP address to bind to
  
  =item *
  
  C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
  
  =item *
  
  C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
  
  =item *
  
  C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
  
  =item *
  
  C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
  
  =item *
  
  C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
  
  =item *
  
  C<timeout> — Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.
  
  =item *
  
  C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
  
  =item *
  
  C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
  
  =back
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Exceptions from C<max_size>, C<timeout> or other errors will result in a
  pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  content field in the response will contain the text of the exception.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  Also, if any connection-relevant
  attributes are modified, or if the process ID or thread ID change, the
  persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback> — A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer> — Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances).
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success> — Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status> — The HTTP status code of the response
  
  =item *
  
  C<reason> — The response phrase returned by the server
  
  =item *
  
  C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an exception during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the exception.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
  thrown if new enough versions of these modules are not installed or if the SSL
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny does not verify server identity>.
  
  Server identity verification is controversial and potentially tricky because it
  depends on a (usually paid) third-party Certificate Authority (CA) trust model
  to validate a certificate as legitimate.  This discriminates against servers
  with self-signed certificates or certificates signed by free, community-driven
  CA's such as L<CAcert.org|http://cacert.org>.
  
  By default, HTTP::Tiny does not make any assumptions about your trust model,
  threat level or risk tolerance.  It just aims to give you an encrypted channel
  when you need one.
  
  Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
  that an SSL connection has a valid SSL certificate corresponding to the host
  name of the connection and that the SSL certificate has been verified by a CA.
  Assuming you trust the CA, this will protect against a L<man-in-the-middle
  attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
  concerned about security, you should enable this option.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.  (This means you trust Mozilla,
  the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
  toolchain used to install it, and your operating system security, right?)
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =back
  
  An exception will be raised if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over SSL connections, the C<SSL_options> attribute
  lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.)
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley David Golden Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař SkyMarshal Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Petr Písař <ppisar@redhat.com>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sören Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2015 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     $VERSION = '0.37';
  }
  
  use strict;
  use warnings;
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list, L<IO::Socket> uses
  C<IO::Socket::IP> rather than C<IO::Socket::INET> as the class that handles
  C<PF_INET>.  C<IO::Socket> will also use C<IO::Socket::IP> rather than
  C<IO::Socket::INET6> to handle C<PF_INET6>, provided that the C<AF_INET6>
  constant is available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my @sockopts_enabled;
     push @sockopts_enabled, SO_REUSEADDR if $arg->{ReuseAddr};
     push @sockopts_enabled, SO_REUSEPORT if $arg->{ReusePort};
     push @sockopts_enabled, SO_BROADCAST if $arg->{Broadcast};
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           $self->setsockopt( SOL_SOCKET, $sockopt, pack "i", 1 ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  
  our $VERSION = '0.56';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    # "0" & $x will modify the flags on the "0" on perl < 5.14, so use a copy
    my $zero = "0";
    # "0" & $num -> 0. "0" & "" -> "". "0" & $string -> a character.
    # this maintains the internal type but speeds up the xor below.
    my $check = $zero & $value;
    return $value
      if length $check
      # 0 ^ itself          -> 0    (false)
      # $character ^ itself -> "\0" (true)
      && !($check ^ $check)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9917;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  
  push @ISA, "version::vpp";
  local $^W;
  
  *version::qv = \&version::vpp::qv;
  *version::declare = \&version::vpp::declare;
  *version::_VERSION = \&version::vpp::_VERSION;
  *version::vcmp = \&version::vpp::vcmp;
  *version::new = \&version::vpp::new;
  *version::numify = \&version::vpp::numify;
  *version::normal = \&version::vpp::normal;
  if ($] >= 5.009000) {
      no strict 'refs';
      *version::stringify = \&version::vpp::stringify;
      *{'version::(""'} = \&version::vpp::stringify;
      *{'version::(<=>'} = \&version::vpp::vcmp;
      *{'version::(cmp'} = \&version::vpp::vcmp;
      *version::parse = \&version::vpp::parse;
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
          local $^W;
          *{$class.'::declare'} =  \&{$CLASS.'::declare'};
          *{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
          map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
          %args =
          (
              qv => 1,
              'UNIVERSAL::VERSION' => 1,
          );
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
          *{$callpkg.'::declare'} =
          sub {return $class->declare(shift) }
          unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
          *{$callpkg.'::qv'} =
          sub {return $class->qv(shift) }
          unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
          local $^W;
          *UNIVERSAL::VERSION
          = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
          *{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
          *{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
          unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
          *{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
          unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9917;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
  
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = 0.9917;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION_REGEX

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.009;
use strict;
use warnings;

package VC3::Builder;

use English qw/-mo_match_vars/;
use Getopt::Long qw/GetOptions/;
use Tie::RefHash;
use Cwd;

use Carp qw( confess );
$SIG{__DIE__} =  \&confess;
$SIG{__WARN__} = \&confess;

my $pwd            = getcwd();
my $vc3_root       = $ENV{VC3_ROOT}       || "${pwd}/vc3-root";
my $vc3_distfiles  = $ENV{VC3_DISTFILES}  || "${pwd}/vc3-distfiles";
my $vc3_user_home  = $ENV{VC3_USER_HOME}  || "vc3-home";
my $vc3_repository = $ENV{VC3_REPOSITORY} || "http://download.virtualclusters.org/repository";
my $vc3_env_output = ".vc3_sh";

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;

# call main if running interactively
VC3::Builder::main();


sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] --require package[:min_version[:max_version]] --require ... [-- command-and-args]

  --database <catalog>  defaults to <internal> if available, otherwise 
                        to ./vc3_catalog.json
  command-and-args      defaults to /bin/sh

  options are:
  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home>.
                        Default is ${vc3_user_home}

  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}
  --repository <url>    Site to fetch packages if needed.
                        Default is ${vc3_repository}

  --make-jobs <n>       Concurrent make jobs. Default is 2.
  --env-to <file>       Write environment scripts to <root>/<home>/<file>{,.init},
                        but do not execute the payload.
  --sh-on-error         On building error, run /bin/sh on the partially-built
                        environment.

Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require maker-example-ecoli-01
EOF

}

sub main {
    my @requires     = ();

    my $print_help   = 0;
    my $make_jobs    = 2;
    my $sh_on_error  = 0;
    my $env_to       = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $dot_output;

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);

    my $database = '<internal>';

    GetOptions(
        "help"        => \$print_help,

        "database=s"  => \$database,
        "require=s"   => \@requires, 

        "install=s"   => \$vc3_root, 
        "home"        => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,
        "sh-on-error" => \$sh_on_error,

        "env-to=s"    => \$env_to,
        "dry-run"     => \$dry_run,

        # options for developing, not for runtime:
        "dot=s"       => \$dot_output,
        "debug-modules-used" => \$debug_modules_used
    );

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        $dry_run = 1;
    }

    unless(@requires) {
        print "At least one --require option should be given.\n\n" . usage($script_name);
        exit 1;
    }

    # set defaults
    my @command_and_args = @ARGV;
    if(!@command_and_args) {
        @command_and_args = ('/bin/sh',);
    }

    # disable stdout buffering
    select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

    my $bag = VC3::Bag->new($database, $dry_run);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
        exit 0;
    }

    $bag->add_builder_variable('MAKEFLAGS',        "-j${make_jobs}");
    $bag->add_builder_variable('VC3_COMMAND_LINE', File::Spec->rel2abs(join(" ", $original_command)));

    for my $req (@requires) {
        $bag->add_requirement($req);
    }

    $bag->build_requirements($sh_on_error);

    if($bag->dry_run) {
        exit 0;
    }

    $bag->prepare_exec_environment();

    if($env_to) {
        $bag->set_environment($env_to, @command_and_args);
    } else {
        $bag->execute(@command_and_args);
        # we get here only when execute fails.
        exit -1;
    }

    exit 0;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink "$vc3_distfiles/$file";

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = $vc3_distfiles  . '/' . $file;

    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);


    my @modules = grep { /\.pm$/ } keys %INC;

    # add modules that %INC sometimes does not find:
    @modules = (@modules, qw/strict PerlIO encoding/);

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

package VC3::Bag; 

use Carp qw/carp croak/;
use English qw/-mo_match_vars/;
use List::Util qw/max/;
use File::Spec ();
use version ();
use POSIX ();

use JSON::Tiny;

sub new {
    my ($class, $catalog, $dry_run) = @_;

    my $self = bless {}, $class;

    $self->{dry_run} = $dry_run;

    $self->{environment_variables} = [];
    $self->set_builder_variables();

    $self->{sources} = $self->decode_bag($catalog);

    # create first environment
    $self->clear_environment();

    my %environment;
    tie %environment, 'Tie::RefHash';

    return $self;
}

sub order_widgets {
    my ($self, @requires) = @_;

    my (%order, %dependencies);

    tie %order, 'Tie::RefHash';
    tie %dependencies, 'Tie::RefHash';

    for my $req (@requires) {
        my $widget = $self->select_version($req->{name}, $req->{min}, $req->{max});
        $widget->order_dependencies(\%order, \%dependencies);
    }

    # list of all packages needed, from inner to outter.
    my @ordered_widgets = sort { $order{$b} <=> $order{$a} || $a->name cmp $b->name } keys %order;
    $self->{order} = \@ordered_widgets;
}

sub check_manual_requirements() {
    my ($self) = @_;

    my @restricted_unmet;
    for my $w (@{$self->{order}}) {
        push @restricted_unmet, $w->msgs_manual_requirements();
        $self->add_to_environment($w);
    }

    if(@restricted_unmet > 0) {
        my ($pid, $build_in) = $self->shell();

        print { $build_in } "cat <<EOF\n";

        for my $msg (@restricted_unmet) {
            for my $line (@{$msg}) {
                print { $build_in } "$line\n";
            }
            print { $build_in } "\n";
        }

        print { $build_in } "EOF\n";
        print { $build_in } "exit 0\n";

        exit 1;
    }

    $self->clear_environment();
    return 1;
}


sub clear_environment {
    my ($self) = @_;

    my %first;
    tie %first, 'Tie::RefHash';

    $self->{environment_stack} = [\%first];
}

sub push_environment {
    my ($self) = @_;

    $self->{environment_stack} ||= [];

    my $current = $self->peak_environment || {};

    my %next;
    tie %next, 'Tie::RefHash';

    # copy to next. manually because widgets are refs, no strings
    for my $w (keys %{$current}) {
        $next{$w} = 1;
    }

    push @{$self->{environment_stack}}, \%next;
}

sub pop_environment {
    my ($self) = @_;
    my $top = pop @{$self->{environment_stack}};

    return $top;
}

sub peak_environment {
    my ($self) = @_;
    return @{$self->{environment_stack}}[-1];
}

sub set_builder_variables {
    my ($self) = @_;

    $self->set_machine_vars();

    $vc3_root      = File::Spec->rel2abs("${vc3_root}");
    $vc3_distfiles = File::Spec->rel2abs("${vc3_distfiles}");

    my $home    = "$vc3_root/$vc3_user_home";
    my $tmp_dir = "$vc3_root/tmp";

    $self->root_dir($vc3_root);
    $self->home_dir($home);
    $self->tmp_dir($tmp_dir);

    File::Path::make_path($vc3_root);
    File::Path::make_path($vc3_distfiles);
    File::Path::make_path("$vc3_distfiles/manual-distribution");
    File::Path::make_path($home);
    File::Path::make_path($tmp_dir);

    $self->add_builder_variable('VC3_ROOT',      $vc3_root);
    $self->add_builder_variable('VC3_DISTFILES', $vc3_distfiles);
    $self->add_builder_variable('HOME',          $home);
    $self->add_builder_variable('TMP',           $tmp_dir);
    $self->add_builder_variable('TERM',          'linux');
    $self->add_builder_variable('USER',          getlogin());
}

sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub add_builder_variable {
    my ($self, $name, $value) = @_;

    my $var = {
        name     => $name,
        value    => $value,
        clobber  => 1,
        absolute => 1
    };

    my $vars = $self->environment_variables;
    push @{$vars}, $var;

    return $var;
}

sub del_builder_variable {
    my ($self, $name) = @_;

    my @vars = @{$self->environment_variables};
    @vars = grep { $name ne $_->{name} } @vars;

    $self->environment_variables(\@vars);
}

sub requirements {
    my ($self, $reqs) = @_;

    $self->{requirements}   = $reqs if($reqs);
    $self->{requirements} ||= [];

    return $self->{requirements};
}

sub add_requirement {
    my ($self, $req) = @_;

    $req =~ m/
    ^
    (?<name> [A-z0-9_]+)
    (:                      # start of min version
    (?<min> [^:]*)
    (:                      # start of max version
    (?<max> [^:]*)
    )?)?
    $
    /x;

    my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});

    # turn into version strings
    $min = "v$min" if($min);
    $max = "v$max" if($max);

    push @{$self->requirements}, { 'name' => $name, 'min' => $min, 'max' => $max };
    $self->order_widgets(@{$self->requirements});
}

sub build_requirements {
    my ($self, $sh_on_error) = @_;

    $self->check_manual_requirements();

    $self->{indent_level} = 0;

    for my $req (@{$self->requirements}) {
        $self->clear_environment();
        $self->build_requirement($req->{name}, $sh_on_error, $req->{min}, $req->{max});
    }

    $self->clear_environment();
}

sub prepare_exec_environment {
    my ($self) = @_;

    $self->clear_environment();
    for my $req (@{$self->requirements}) {
        $self->collect_environment($req->{name}, $req->{min}, $req->{max});
    }
}

sub collect_environment {
    my ($self, $requirement, $min_version, $max_version) = @_;
    
    my $widget = $self->select_version($requirement, $min_version, $max_version);
    $self->add_to_environment($widget);

    $self->{dependencies}{$widget->name} ||= {};

    my @all_dependencies;

    if($widget->dependencies) {
        push @all_dependencies, $widget->dependencies;
    }

    if($widget->active_source && $widget->active_source->dependencies) {
        push @all_dependencies, $widget->active_source->dependencies;
    }

    for my $dependencies (@all_dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_dep_ver, $max_dep_ver) = @{$dependencies->{$dependency}};

            $self->collect_environment($dependency, $min_dep_ver, $max_dep_ver);
            $self->{dependencies}{$widget->name}{$dependency} = 1;
        }
    }
}


sub root_dir {
    my ($self, $root) = @_;

    $self->{root_dir} = $root if($root);

    return $self->{root_dir};
}

sub home_dir {
    my ($self, $home) = @_;

    $self->{home_dir} = $home if($home);

    return $self->{home_dir};
}

sub tmp_dir {
    my ($self, $tmp) = @_;

    $self->{tmp_dir} = $tmp if($tmp);

    return $self->{tmp_dir};
}

sub dry_run {
    my ($self) = @_;
    return $self->{dry_run};
}

sub set_machine_vars {
    my ($self) = @_;

    ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();

    $self->{target} = $self->architecture . '/' . $self->distribution;

    my $ldd_version_raw = qx(ldd --version);
    $ldd_version_raw =~ /
    # we are looking for a line starting with 'ldd'
    ^ldd
    # followed by anything
    .*
    # followed by at least one space
    \s+
    # followed by the version number (that we capture)
    ([0-9.]+)
    # followed by any number of spaces at the end of the line
    \s*$
    # options: x allows regexp comments. m treats each line indepedently
    /xm ;

    $self->{glibc_version} = $1
    || 'unknown';

    $self->add_builder_variable('VC3_MACHINE_OS',            $self->osname);
    $self->add_builder_variable('VC3_MACHINE_ARCH',          $self->architecture);
    $self->add_builder_variable('VC3_MACHINE_GLIBC_VERSION', $self->glibc_version);
}

sub target {
    my ($self) = @_;
    return $self->{target};
}

sub osname {
    my ($self) = @_;
    return $self->{osname};
}

sub architecture {
    my ($self) = @_;
    return $self->{architecture};
}

sub glibc_version {
    my ($self) = @_;
    return $self->{glibc_version};
}

# reads /etc/readhat-release and transforms something like:
# 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
# into 'redhat6'.
sub distribution {
    my ($self) = @_;

    my $distribution='generic';
    
    if (-f '/etc/redhat-release') {
        open (my $file_fh, '<', '/etc/redhat-release');
        my $redhat_version_line = <$file_fh>;

        $redhat_version_line =~ /\brelease\b\s+([0-9]+)\b/;
        my $redhat_version = $1;

        die 'Could not find redhat version!' unless $redhat_version;

        $distribution="redhat${redhat_version}"
    }
    
    return $distribution;
}

sub widget {
    my ($self, $widget_name) = @_;

    my $widget = $self->{sources}{$widget_name}
    || die "I do not know anything about '$widget_name' . \n";

    return $widget;
}

sub decode_bag {
    my ($self, $filename) = @_;

    {
        no warnings;
        if($filename eq '<internal>' && tell(VC3::Builder::DATA) == -1) {
            $filename = './vc3-catalog.json';
        }
    }


    my $catbag_f;
    if($filename eq '<internal>') {
        $catbag_f = *VC3::Builder::DATA;
    } else {
        open($catbag_f, '<:encoding(UTF-8)', $filename) ||
        die "Could not open '$filename': $!";
    }

    my $contents = do { local($/); <$catbag_f> };
    close($catbag_f);

    my $bag_raw = JSON::Tiny::decode_json($contents);

    my $sources = {};
    
    for my $widget_name (keys %{$bag_raw}) {
        my @versions = map { VC3::Widget->new($self, $widget_name, $_) } @{$bag_raw->{$widget_name}};
        $sources->{$widget_name} = \@versions;
    }

    return $sources;
}

sub build_requirement {
    my ($self, $widget_name, $sh_on_error, $min_version, $max_version) = @_;

    my $widget = $self->select_version($widget_name, $min_version, $max_version);

    $self->say("processing for $widget_name-" . $widget->version);

    if($widget->active_source && $widget->active_source->dependencies) {
        $self->set_dependencies($widget, $sh_on_error, $widget->active_source->dependencies);
    }

    $self->set_dependencies($widget, $sh_on_error, $widget->dependencies);

    # check here missing, we are not checking anything here, only below at
    # sources!
    $self->say("checking for $widget_name-" . $widget->version);
    ####

    my $exit_status = 0;
    if($widget->sources) { 
        for my $source (@{$widget->sources}) {
            # save current environment so that we can rollback in case of error.
            $self->push_environment();

            # set dependencies particular to this source
            $self->set_dependencies($widget, $sh_on_error, $source->dependencies);
            eval {$exit_status = -1; $exit_status = $widget->execute_recipe($source);};

            if($exit_status) {
                # on error, reestablish old environment, and show last lines of log
                # file.
                
                $widget->process_error($sh_on_error, $EVAL_ERROR, $exit_status);
                $self->pop_environment();
            } else {
                # on success, we keep break out and do no try more recipes.
                # we also record the succesful recipe.
                $widget->active_source($source);
                last;
            }
        }
    }

    # last of the tries also failed, so we report failure for this widget.
    if($exit_status) {
        die "Could not set environment for '" . $widget->name . "' succesfully' . \n";
    }
    
    $self->add_to_environment($widget);
}

sub set_dependencies {
    my ($self, $widget, $sh_on_error, $dependencies) = @_;

    # set root of this widget, in case dependencies need to refer to its parent.
    $self->add_builder_variable($widget->var_root_name, $widget->destination_dir);

    my $namev = $widget->name . '-' . $widget->version; 
    $self->{indent_level}++;
    
    if($dependencies) {
        for my $dependency (keys %{$dependencies}) {
            my ($min_dep_ver, $max_dep_ver) = @{$dependencies->{$dependency}};

            $self->say("$namev needs $dependency");

            $self->build_requirement($dependency, $sh_on_error, $min_dep_ver, $max_dep_ver);
        }
    }

    $self->del_builder_variable($widget->var_root_name);

    $self->{indent_level}--;
}

# versions available, min desired version, max desired version
sub select_version {
    my ($self, $widget_name, $min_version, $max_version) = @_;

    if($min_version) {
        $min_version = version->parse($min_version);
    }

    if($max_version) {
        $max_version = version->parse($max_version);
    }

    my $min_found;
    my $max_found;

    my $versions = $self->widget($widget_name);

    for my $widget (@{$versions}) {
        if(!$min_version) {
            return $widget;
        }

        my $version = version->parse($widget->{version});

        $min_found = $version unless $min_found;
        $max_found = $version unless $max_found;

        $min_found = $min_found lt $version ? $version : $min_found;
        $max_found = $max_found gt $version ? $version : $max_found;

        next if $min_version gt $version;

        if(!$max_version) {
            return $widget;
        }

        next if $max_version lt $version;
        return $widget;
    }

    $max_version = $min_version unless $max_version;
    die "I did not find a suitable version for '$widget_name'.\n Found: ["
    . version::normal($min_found)
    . ',' . version::normal($max_found)
    . ']. Wanted ['
    . $min_version->normal
    . ',' . $max_version->normal
    . "]\n";
}

sub dot_graph {
    my ($self, $dotname) = @_;

    open(my $dot_f, '>', $dotname) 
    || die "Could not open '$dotname': $!";

    print { $dot_f } "digraph {\n";

    #$self->{dependencies}{vc3_builder} = {};
    #$self->{dependencies}{vc3_builder}{$_} = 1 for @external_dependencies;

    for my $pkg (keys %{$self->{dependencies}}) {
        my @deps = keys %{$self->{dependencies}{$pkg}};

        if(@deps) {
            for my $dep (@deps) {
                print { $dot_f } qq(\t"$dep"->"$pkg";\n);
            }
        } else {
            print { $dot_f } qq(\t"$pkg";\n);
        }
    }

    print { $dot_f } "}\n";

    close $dot_f;
}

sub add_to_environment {
    my ($self, $widget) = @_;

    my $env = $self->peak_environment;

    $env->{$widget} = 1;
}

sub set_environment_variables {
    my ($self, $sh_f) = @_;

    my $env = $self->peak_environment();

    my $expansion = {};

    for my $var (@{$self->environment_variables}) {
        $expansion->{$var->{name}} = [$var->{value}];
    }

    for my $wid (@{$self->{order}}) {
        next unless $env->{$wid};
        $wid->consolidate_environment_variables($expansion);
    }

    $expansion->{'PATH'} ||= [];
    push @{$expansion->{'PATH'}}, qw(/bin /usr/bin);

    for my $var_name (keys %{$expansion}) {
        $expansion->{$var_name} = join(':', @{$expansion->{$var_name}});
    }

    my @ordered = $self->order_variables($expansion);

    for my $var_name (@ordered) {
        my $value = $expansion->{$var_name};
        print { $sh_f } "export $var_name=\"$value\"\n";
    }
}

sub order_variables {
    my ($self, $expansion) = @_;

    my @alpha = sort { $a cmp $b } keys %{$expansion};

    my $order = {};

    my $index = 1;
    for my $var (@alpha) {
        $order->{$var} = $index;
        $index++;
    }

    my $total_passes = 0;
    my $swap       = 1;

    while($swap) {
        $swap = 0;

        my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};

        for my $var (@ordered) {
            my $value = $expansion->{$var};
            my @deps  = ($value =~ m/\$\{(\w+)\}/g);

            next unless @deps;

            my $org   = $order->{$var};
            my $nxt   = 1 + max(map { $order->{$_} || carp "Variable '$_' is not defined." } @deps);

            if($nxt > $org) {
                $swap++;
                $order->{$var} = $nxt;
            }
        }

        $total_passes++;
        carp "Cyclic dependency in environment variables." if $total_passes > @alpha;
    }

    my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
    return @ordered;
}


sub set_wrapper {
    my ($self, $wrapper_file, $profile_file) = @_;

    my $env = $self->peak_environment;

    my $payload = "/bin/sh -c '. $profile_file'";
    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        my $wrap = $w->wrapper;

        next unless $wrap;

        if( $wrap =~ /\{\}/ ) {
            $wrap =~ s/\{\}/$payload/;
            $payload = $wrap;
        } else {
            $payload = $wrap . ' ' . $payload;
        }
    }


    # write to $env_file
    open(my $sh_f, '>', "$wrapper_file")
    || die "Could not open file $wrapper_file: $!";

    print { $sh_f } "#!/usr/bin/env -i /bin/sh\n\n";

    $self->set_environment_variables($sh_f);

    print { $sh_f } "\ncd $vc3_root/$vc3_user_home\n";
    print { $sh_f } "exec $payload\n\n";
    return $payload;
}

sub consolidate_prologue {
    my ($self) = @_;

    my $env = $self->peak_environment;

    my @progs = ("cd $vc3_root/$vc3_user_home");

    for my $w (@{$self->{order}}) {
        next unless $env->{$w};

        if($w->prologue) {
            push @progs, @{$w->prologue};
        }
    }


    return \@progs;
}

sub set_profile {
    my ($self, $profile_file, @command_and_args) = @_;

    # write to $profile
    open(my $profile_f, '>', $profile_file)
    || die "Could not open file '$profile_file': $!";

    print { $profile_f } "#!/bin/sh\n\n";

    my $prologue = $self->consolidate_prologue();
    for my $line (@{$prologue}) {
        print { $profile_f } "$line\n";
    }

    if(@command_and_args) {
        print { $profile_f } join(' ', 'exec', @command_and_args, "\n");
    }
    close $profile_f;
}

sub set_environment {
    my ($self, $wrapper_file, @command_and_args) = @_;

    $wrapper_file = $self->home_dir . "/$wrapper_file";
    my $profile_file = "$wrapper_file.init";

    $self->set_profile($profile_file, @command_and_args);
    $self->set_wrapper($wrapper_file, $profile_file);
}


sub execute {
    my ($self, @command_and_args) = @_;

    $self->set_environment($vc3_env_output, @command_and_args);
    exec "/usr/bin/env -i /bin/sh -c '. " . $self->home_dir . "/$vc3_env_output'";
}

sub shell {
    my ($self, $payload) = @_;

    $payload |= '/bin/sh';

    $self->set_environment($vc3_env_output, $payload);

    my $pid = open(my $input, '|-', "/usr/bin/env -i /bin/sh -c '. " . $self->home_dir . "/$vc3_env_output'");

    return ($pid, $input);
}

sub shell_user {
    my ($self, $payload) = @_;

    $payload |= '/bin/sh';

    $self->set_environment($vc3_env_output, $payload);
    my $status = system("/usr/bin/env -i /bin/sh -c '. " . $self->home_dir . "/$vc3_env_output'");

    return $status;
}

sub say {
    my ($self, @rest) = @_;
    print(('.' x $self->{indent_level}), @rest, "\n");
}


package VC3::Widget;
use Carp;
use POSIX ":sys_wait_h";
use IO::Handle;
use Digest::MD5 qw(md5_hex);

use JSON::Tiny;

# Attributes:
# name, version, sources, dependencies, environment_variables
sub new {
    my ($class, $bag, $name, $json_description) = @_;

    my $self = bless {}, $class;

    $self->bag($bag);
    $self->name($name);
    $self->version($json_description->{version});
    $self->sources($json_description->{sources});
    $self->dependencies($json_description->{dependencies});
    $self->wrapper($json_description->{wrapper});
    $self->prologue($json_description->{prologue});
    $self->environment_variables($json_description->{environment_variables});
    $self->phony($json_description->{phony});

    $self->checksum($json_description);

    add_root_variable($self);

    return $self;
}

sub add_root_variable {
    my ($self) = @_;

    my $vars      = $self->environment_variables || [];

    my $root_name = 'VC3_ROOT_' . uc($self->name);

    # replace - with _, as env vars cannot have - in their names.
    $root_name =~ s/-/_/g;

    my $root_var = {
        name     => $root_name,
        value    => '${VC3_ROOT}/' . $self->destination_dir(1),
        clobber  => 1,
        absolute => 1
    };

    unshift @{$vars}, $root_var;

    $self->var_root_name($root_name);
    $self->environment_variables($vars);
}

sub var_root_name {
    my ($self, $new_var_root_name) = @_;

    $self->{var_root_name} = $new_var_root_name if($new_var_root_name);

    return $self->{var_root_name};
}

sub bag {
    my ($self, $new_bag) = @_;

    $self->{bag} = $new_bag if($new_bag);

    croak 'No bag given'
    unless($self->{bag}); 

    return $self->{bag};
}

sub name {
    my ($self, $new_name) = @_;

    if($new_name) {
        # names can only contain letters, numbers, - and _.
        my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
        if(@badchars) {
            die "The name '$new_name' containes the following disallowed charactares: " 
            . join ', ', map { "'$_'" } @badchars;
        } else {
            $self->{name} = $new_name if($new_name);
        }
    }

    die 'No name given'
    unless($self->{name}); 

    return $self->{name};
}

sub version {
    my ($self, $new_version) = @_;

    $self->{version} = $new_version if($new_version);

    croak 'No version given'
    unless($self->{version}); 

    return $self->{version};
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub sources {
    my ($self, $new_sources) = @_;

    if($new_sources) {
        my @sources = map { VC3::Source->new($self, $_) } @{$new_sources};
        $self->{sources} = \@sources;
    }

    return $self->{sources};
}

sub active_source {
    my ($self, $source) = @_;

    if($source) {
        $self->{active_source} = $source;
    }

    return $self->{active_source};
}

sub prologue {
    my ($self, $new_prologue) = @_;

    $self->{prologue} = $new_prologue if($new_prologue);

    return $self->{prologue};
}

sub wrapper {
    my ($self, $new_wrapper) = @_;

    $self->{wrapper} = $new_wrapper if($new_wrapper);

    return $self->{wrapper};
}


sub environment_variables {
    my ($self, $new_vars) = @_;

    $self->{environment_variables} = $new_vars if($new_vars);

    return $self->{environment_variables};
}

sub phony {
    my ($self, $new_phony) = @_;

    $self->{phony} = $new_phony if($new_phony);

    return $self->{phony};
}

sub destination_dir {
    my ($self, $relative) = @_;

    my $rel = $self->bag->target . '/' . $self->name . '-' . $self->version;

    if($relative) {
        return $rel;
    }

    return File::Spec->rel2abs($vc3_root) . '/' . $rel;
}

sub build_dir {
    my ($self) = @_;
    return File::Spec->rel2abs($vc3_root) . '/builds/' . $self->name;
}

sub build_log {
    my ($self) = @_;
    my $log_name = $self->destination_dir . '/' . $self->name . '-build-log';

    return $log_name;
}

sub completion_ribbon {
    my ($self) = @_;
    my $ribbon = $self->destination_dir . '/.VC3_DEPENDENCY_BUILD';

    return $ribbon;
}

sub check_ribbon {
    my ($self) = @_;

    my $ribbon = $self->completion_ribbon();
    return 0 unless -f $ribbon;

    open my $ribbon_fh, '<', $ribbon || return 0;

    my $contents = do { local($/); <$ribbon_fh> };
    close($ribbon_fh);

    my $report = JSON::Tiny::decode_json($contents);

    return 0 unless $report->{checksum};
    return 0 unless $report->{checksum} eq $self->checksum;

    return 1;
}

sub consolidate_environment_variables {
    my ($self, $expansion) = @_; 

    my $vars = $self->environment_variables
    || return;

    for my $var (@{$vars}) {

        my $name = $var->{name}
        || carp "Environment variable does not have a name.";

        my $value = $var->{value}
        || carp "Environment variable '$name' did not define a value.";

        my $clobber  = $var->{clobber};
        my $absolute = $var->{absolute};

        if($expansion->{$name} && $clobber) {
            carp("Asked to clobber variable '%s', but it already had a value.", $name);
        }

        $expansion->{$name} ||= [];

        my @paths;
        if($clobber) {
            # when clobber, we use the value as is.
            @paths = ($value);
        } else {
            # otherwise, split paths on :
            @paths = split /:/, $value;
        }

        for my $path (@paths) {
            if(!$absolute) {
                $path = '${' . $self->var_root_name . '}/' . $path;
            }

            push @{$expansion->{$name}}, $path;
        }
    }
}

# range is: [min_version, max_version];
# max_version is the prefered version. 
# [version] is considered as [min_version]
# sub check_version {
#     my ($self, @range) = @_;
# 
#     return 1 unless $self->versioncmd;
#     return 1 unless $self->version || @range > 0;
# 
#     if(@range == 0) {
#         @range = (version->parse($self->{version}));
#     }
# 
#     my $reg = $self->{versionreg} ? $self->{versionreg} : qr/(.*)/;
# 
#     my $version_output = qx/$self->{versioncmd}/;
# 
#     return 0 unless $version_output =~ $reg;
# 
#     my ($observed_version) = version->parse("$1");
# 
#     print $observed_version . "\n";
# 
#     return 0 if $observed_version < $range[0];
#     return 0 if $observed_version > $range[$#range];
# 
#     return $observed_version;
# }

sub error_debug_info {
    my ($self, $eval_error) = @_;

    print "'", $self->name, "' failed to build for ", $self->bag->target, "\n";

    if($eval_error) {
        print $eval_error, "\n";
    }

    print "Last lines of log file:\n";
    system('tail', $self->build_log);
}


sub process_error {
    my ($self, $sh_on_error, $eval_error, $status) = @_;

    if($eval_error || $status) {
        $self->error_debug_info($eval_error);

        if($sh_on_error) {
            warn $@ if $@;

            my $cwd = getcwd();

            chdir $self->build_dir;
            $self->bag->shell_user();

            chdir $cwd;
        }
    }
}

sub create_ribbon {
    my ($self) = @_;

    my $ribbon_fh = IO::Handle->new();
    open ($ribbon_fh, '>', $self->completion_ribbon);

    my $report = {};
    $report->{'checksum'} = $self->checksum;

    printf { $ribbon_fh } JSON::Tiny::encode_json($report);

    $ribbon_fh->flush();
    $ribbon_fh->sync();

    $ribbon_fh->close();
}

sub checksum {
    my ($self, $load) = @_;

    if($load) {
        my $txt = $self->hash_to_canonical_str($load);
        my $dgt = md5_hex($txt);

        $self->{'checksum'} = $dgt;
    }

    return $self->{'checksum'};
}

sub hash_to_canonical_str {
    my ($self, $ref) = @_;

    my $str;

    if(ref($ref) eq 'HASH') {
        my @ks = sort { $a cmp $b } keys %{$ref};

        $str 
        = '{'
        . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
        . '}';
    } elsif(ref($ref) eq 'ARRAY') {
        $str 
        = '['
        . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
        . ']';
    } else {
        $str = $ref;
    }

    return $str;
}

sub prepare_recipe_sandbox {
    my ($self, $source) = @_;

    # clear build directory, to avoid bugs from uncleaned sources.
    my $build = $self->build_dir;
    if( -d $build ) {
        File::Path::rmtree($build);
    }

    # clear destination directory, to make sure we are running what we believe
    # we are running.
    my $destination = $self->destination_dir;
    if( -d $destination ) {
        File::Path::rmtree($destination);
    }

    # create the dirs we cleared above.
    File::Path::make_path($self->build_dir);
    File::Path::make_path($self->destination_dir);

    # make sure tmp dir exists
    File::Path::make_path($self->bag->tmp_dir);

    # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
    $source->get_files();

    # if generic, copy all files to build directory.
    # if tarball, expand first file to build directory, and copy the rest of
    # the files to build directory.
    $source->prepare_files($build);
}

sub execute_recipe {
    my ($self, $source) = @_;

    # if nothing to do, we return no error:
    if(!$self->phony && $self->check_ribbon()) {
        return 0;
    }

    $self->bag->say("preparing '" . $self->name . "' for ", $self->bag->target);

    if($self->bag->dry_run) {
        return 0;
    }

    $self->prepare_recipe_sandbox($source);

    # set the destination directory as an environment variable before
    # setting up the shell, so that the child created inherets it.
    $self->bag->push_environment();

    $self->bag->add_builder_variable('VC3_PREFIX', $self->destination_dir);
    $self->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);

    my ($pid, $build_in) = $self->setup_build_shell($source);

    my @steps = @{$source->recipe};

    # add shifting to build directory as the first step.
    unshift @steps, 'cd ' . $self->build_dir;

    # add exiting cleanly from shell as a last step.
    push @steps, 'exit 0';

    $self->bag->say("building '" . $self->name . "' for ", $self->bag->target);
    $self->bag->say("details: " . $self->build_log);

    for my $step (@steps) {
        my $date = gmtime();
        print { $build_in } ": $date\n";
        print { $build_in } "$step\n";
    }

    my $status = -1;
    eval { close $build_in; $status = $? };

    $self->bag->pop_environment();

    $self->bag->del_builder_variable('VC3_PREFIX');
    $self->bag->del_builder_variable('VC3_BUILD');

    if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
        $self->create_ribbon();
        File::Path::rmtree($self->build_dir);
        return 0;
    } else {
        return -1;
    }
}

sub setup_build_shell {
    my ($self, $source) = @_;

    # log the recipe used. Since we are opening sh with -e, the recipe executes
    # as if all steps were &&-ed together.
    open(my $build_log, '>', $self->build_log);
    print { $build_log } join("\n && ", @{$source->recipe}) . "\n";
    close $build_log;

    # open sh with -e. This terminates the shell at the first step that returns
    # a non-zero status.
    my ($pid, $build_in) = $self->bag->shell();

    croak 'Could not open /bin/sh for building.'
    unless $build_in;

    # redirect all output to our log file.
    print { $build_in } 'exec 1>> ' . $self->build_log . "\n";
    print { $build_in } "exec 2>&1\n";
    print { $build_in } "set -ex\n";

    # return the stdin of the shell, and the pid so we can wait for it.
    return ($pid, $build_in);
}

sub msgs_manual_requirements {
    my ($self) = @_;

    my $sources = $self->sources;

    my @restricted_unmet;
    for my $source (@{$sources}) {
        unless($source->check_manual_requirements()) {
            push @restricted_unmet, $source->msg_manual_requirement();
        }
    }

    return @restricted_unmet;
}


sub order_dependencies {
    my ($self, $order) = @_;

    # if no parents, then give level one, a root package
    # larger level means more inner 
    $order->{$self} |= 1;

    my $level = $order->{$self};

    $self->order_dependency($level, $self, $order);

    if($self->sources) {
        for my $s (@{$self->sources}) {
            $self->order_dependency($level, $s, $order);
        }
    }
}

sub order_dependency {
    my ($self, $level, $dep, $order) = @_;

    my $wdeps = $dep->dependencies;

    return unless $wdeps;

    for my $dependency (keys %{$wdeps}) {
        my ($min_ver, $max_ver) = @{$wdeps->{$dependency}};
        my $next = $self->bag->select_version($dependency, $min_ver, $max_ver);


        my $next_level = $order->{$next} || 0;

        if($next_level < $level + 1) {
            $order->{$next} = $level + 1;
            $next->order_dependencies($order);
        }
    }
}

package VC3::Source;
use Carp;

sub new {
    my ($class, $widget, $source_raw) = @_;

    my $source;

    if($source_raw->{type} eq 'generic') {
        $source = VC3::Source::Generic->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'tarball') {
        $source = VC3::Source::Tarball->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'manual-distribution') {
        $source = VC3::Source::ManualDist->new($widget, $source_raw);
    }
    elsif($source_raw->{type} eq 'service') {
        croak "Not implemented";
    }
    else {
        croak "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->name . "'";
    }

    return $source;
}

package VC3::Source::Generic;
use Carp;
use File::Copy;
use File::Path;
use File::Spec;
use HTTP::Tiny;
use parent;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = bless {}, $class;

    $self->widget($widget);
    $self->recipe($json_description->{recipe});
    $self->files($json_description->{files});
    $self->msg_manual_requirement($json_description->{msg_manual_requirement});
    $self->dependencies($json_description->{dependencies});

    return $self;
}

sub widget {
    my ($self, $new_widget) = @_;

    $self->{widget} = $new_widget if($new_widget);

    croak 'No environment argument given'
    unless($self->{widget}); 

    return $self->{widget};
}

sub recipe {
    my ($self, $new_recipe) = @_;

    $self->{recipe} = $new_recipe if($new_recipe);

    croak 'No recipe given'
    unless($self->{recipe}); 

    return $self->{recipe};
}

sub files {
    my ($self, $new_files) = @_;

    $self->{files} = $new_files if($new_files);

    if($self->{files}) {
        return $self->{files};
    } else {
        return [];
    }
}

sub msg_manual_requirement {
    my ($self, $new_message) = @_;

    if($new_message) {
        $self->{msg_manual_requirement} = $new_message;
    }

    return $self->{msg_manual_requirement};
}

sub check_manual_requirements {
    my ($self, $new_message) = @_;

    # by default return true. Usually packages do not have manual requirements.
    return 1;
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/' . $file);
}

sub dependencies {
    my ($self, $new_dependencies) = @_;

    $self->{dependencies} = $new_dependencies if($new_dependencies);

    return $self->{dependencies};
}

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        $self->widget->bag->say("Downloading '" . $file . "' from $vc3_repository");

        #if make sure the destination directory exists
        File::Path::make_path($vc3_distfiles);

        my $ff = HTTP::Tiny->new();

        my $url    = $vc3_repository . '/' . $file;
        my $output = $vc3_distfiles  . '/' . $file;

        my $retries = 5;
        my $sleep_before_retry = 5; # seconds
        my $response;

        for my $i (1..$retries) {
            $response = $ff->mirror($url, $output);

            return if $response->{success};

            # 304 means file did not change from the last time we downloaded it
            return if $response->{status} == 304;

            # retries:
            # 408 is request timeout
            # 503 is service unavailable
            # 504 is a gatewat timeout
            # 524 is a cloudflare timeout
            # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.

            if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
                print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
                print "$response->{content}\n" if $response->{content};
                print "Retrying @{[$retries - $i]} more time(s)\n"; 

                sleep $sleep_before_retry;

                next;
            }

            die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
        }
    }
}

sub get_files {
    my ($self) = @_;

    my $files = $self->files;

    for my $file (@{$files}) {
        $self->get_file($file);
    }
}

sub prepare_files {
    my ($self, $build_dir) = @_;

    for my $file (@{$self->files}) {
        symlink($self->file_absolute($file), $build_dir . '/' . $file)
        || die "Could not link '" . $file . "' to build directory.\n";
    }
}

package VC3::Source::Tarball;
use base 'VC3::Source::Generic';
use Carp;

sub new {
    my ($class, $widget, $json_description) = @_;

    my $self = VC3::Source::Generic->new($widget, $json_description);

    unless($self->files) {
        croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
    }

    $self = bless $self, $class;

    return $self;
}

sub prepare_files  {
    my ($self, $build_dir) = @_;

    # first file in $self->files is the tarball, by convention.
    my $tarball = @{$self->files}[0];
    $tarball = $self->file_absolute($tarball);

    system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
    die "Could not expand tarball $tarball.\n" if $?;

    # link in the rest of the input files.
    $self->SUPER::prepare_files($build_dir);
}

package VC3::Source::ManualDist;
use base 'VC3::Source::Generic';
use Carp;

sub get_file {
    my ($self, $file) = @_;

    unless(-f $self->file_absolute($file)) {
        die "Missing manual or restricted distribution file '$file'.\n";
    }
}

sub file_absolute {
    my ($self, $file) = @_;
    return File::Spec->rel2abs($vc3_distfiles . '/manual-distribution/'  . $file);
}

sub check_manual_requirements {
    my ($self) = @_;

    for my $file (@{$self->files}) {
        unless(-f $self->file_absolute($file)) {
            # check failed, return false
            return 0;
        }
    }

    return 1;
}


package VC3::Builder;
__DATA__
{
    "icecube-argonne-demo":[
        {
            "version":"v1.0",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "icecube-argonne-demo-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${HOME}/icecube-argonne-demo-01",
                        "tar -C ${HOME}/icecube-argonne-demo-01 --strip-components=1 -xpf icecube-argonne-demo-01.tar.gz"
                    ]
                }
            ],
            "dependencies":{
                "icecube-environment":[
                    "v1.0"
                ],
                "python":[
                    "v2.6"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${HOME}/icecube-argonne-demo-01",
                    "absolute":1
                }
            ]
        }
    ],

    "icecube-environment":[
        {
            "version":"v1.0",
            "phony":1,
            "prologue": [
                "eval $(/cvmfs/icecube.opensciencegrid.org/py2-v1/setup.sh)"
            ],
            "dependencies":{
                "cvmfs":[
                    "v2.0"
                ],
                "python":[
                    "v2.6"
                ]
            }
        }
    ],

    "htcondor-glidein-wrapper":[
        {
            "version":"v1.0",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "htcondor-glidein-wrapper"
                    ],
                    "recipe":[
                        "chmod 755 htcondor-glidein-wrapper",
                        "mkdir ${VC3_PREFIX}/bin",
                        "cp htcondor-glidein-wrapper ${VC3_PREFIX}/bin"
                    ],
                    "dependencies":{
                        "python":[
                            "v2.6"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "cvmfs":[
        {
            "version":"v2.0",
            "phony":1,
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "stat /cvmfs/cms.cern.ch"
                    ]
                },
                {
                    "type":"generic",
                    "recipe":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "dependencies":{
                        "parrot":[
                            "v6.0.16"
                        ]
                    }
                }
            ]
        }
    ],

    "parrot":[
        {
            "version":"v6.0.16",
            "versioncmd":"parrot_run --version",
            "versionreg":"^parrot_run version ([0-9.]*)",
            "wrapper":"parrot_run --dynamic-mounts -p ${PARROT_HTTP_PROXY} --cvmfs-repo-switching -- {}",
            "dependencies":{
                "cctools":[
                    "v6.0.16"
                ]
            }
        }
    ],

    "cctools":[
        {
            "version":"v6.0.16",
            "versioncmd":"parrot_run --version",
            "versionreg":"^parrot_run version ([0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cctools-6.0.16-source.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --with-swig-path ${VC3_ROOT_SWIG} --with-python-path ${VC3_ROOT_PYTHON} --with-perl-path ${VC3_ROOT_PERL} --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --without-system-umbrella  --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_FUSE}",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "swig":[
                            "v3.0"
                        ],
                        "python":[
                            "v2.7"
                        ],
                        "perl":[
                            "v5.10"
                        ],
                        "libcvmfs":[
                            "v2.2"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "uuid":[
                            "v1.0"
                        ]
                    }
                }
            ],
            "dependencies":{
                "python":[
                    "v2.6"
                ],
                "perl":[
                    "v5.8"
                ],
                "zlib":[
                    "v1.2"
                ]
            },
            "environment_variables":[
                {
                    "name":"PARROT_HTTP_PROXY",
                    "value":"http://cache01.hep.wisc.edu:3128",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"PYTHONPATH",
                    "value":"lib/python2.7/site-packages"
                },
                {
                    "name":"PERL5LIB",
                    "value":"lib/perl5/site_perl"
                }
            ]
        }
    ],

    "swig":[
        {
            "version":"v3.0.2",
            "versioncmd":"swig -version",
            "versionreg":"SWIG Version ([0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "swig-3.0.2.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "python":[
                            "v2.6"
                        ],
                        "perl":[
                            "v5.8"
                        ],
                        "pcre":[
                            "v8.34"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "patch":[
        {
            "version":"v2.7.5",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "patch-2.7.5.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "cmake":[
        {
            "version":"v3.5.2",
            "versioncmd":"cmake --version",
            "versionreg":"cmake version ([0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cmake-3.5.2.tar.gz"
                    ],
                    "recipe":[
                        "./bootstrap --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "libcvmfs":[
        {
            "version":"v2.3",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "cvmfs-0941e442.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        ": set NO_INTERNET to stop parcparser tests",
                        "export NO_INTERNET=1",
                        "cmake -Wno-dev -DINSTALL_MOUNT_SCRIPTS=OFF -DBUILD_SERVER:BOOL=OFF -DBUILD_CVMFS:BOOL=OFF -DBUILD_LIBCVMFS:BOOL=ON -DINSTALL_BASH_COMPLETION:BOOL=OFF -DUUID_LIBRARY=${VC3_ROOT_UUID}/lib/libuuid.a -DUUID_INCLUDE_DIR:PATH=${VC3_ROOT_UUID}/include -DOPENSSL_ROOT_DIR:PATH=${VC3_ROOT_OPENSSL} -DOPENSSL_INCLUDE_DIR:PATH=${VC3_ROOT_OPENSSL}/include -DOPENSSL_LIBRARIES:PATH=${VC3_ROOT_OPENSSL}/lib -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} ..",
                        "make libpacparser",
                        "cd cvmfs",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "uuid":[
                            "v1.0"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "cmake":[
                            "v3.1"
                        ],
                        "patch":[
                            "v2.0"
                        ],
                        "attr":[
                            "v2.4"
                        ],
                        "openssl":[
                            "v1.0"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib64"
                }
            ]
        }
    ],

    "uuid":[
        {
            "version":"v1.0.3",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "libuuid-1.0.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "openssl":[
        {
            "version":"v1.0.2",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "openssl-1.0.2h.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./config --prefix=${VC3_PREFIX} --libdir=lib zlib-dynamic",
                        "make depend",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.2"
                ]
            },
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "berkeley-db":[
        {
            "version":"v6.2.23",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "db-6.2.23.tar.gz"
                    ],
                    "recipe":[
                        "cd build_unix",
                        "export CFLAGS=-fPIC",
                        "export CXXFLAGS=-fPIC",
                        "../dist/configure --prefix=${VC3_PREFIX} --enable-static --enable-shared --enable-compat185 --enable-dbm --enable-cxx",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "readline":[
        {
            "version":"v6.3",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "readline-6.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "glib":[
        {
            "version":"v2.18.1",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "glib-2.48.1.tar.gz"
                    ],
                    "recipe":[
                        ": system pcre is not working! using internal",
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --with-python=${VC3_ROOT_PYTHON}/bin/python --with-pcre=internal",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "libffi":[
                    "v3.2.1"
                ],
                "gettext":[
                    "v0.19"
                ],
                "zlib":[
                    "v1.2"
                ],
                "pcre":[
                    "v8.13"
                ],
                "python":[
                    "v2.5"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "attr":[
        {
            "version":"v2.4.47",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "attr-2.4.47.src.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --enable-static --enable-shared",
                        "make",
                        "make install install-dev install-lib",
                        "chmod -v 755 ${VC3_PREFIX}/lib/libattr.so"
                    ]
                }
            ],
            "dependencies":{
                "gettext":[
                    "v0.19"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "libffi":[
        {
            "version":"v3.2.1",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "libffi-3.2.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --enable-portable-binary",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib64:lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "pcre":[
        {
            "version":"v8.39",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "pcre-8.39.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --disable-shared --enable-unicode-properties --enable-pcre16 --enable-pcre32 ",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "fuse":[
        {
            "version":"v2.9.3",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "fuse-2.9.3.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib  --enable-lib --disable-util",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "perl":[
        {
            "version":"v5.24.0",
            "sources": [
                {
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "cd ${VC3_PREFIX}",
                        "ln -sf ${VC3_ROOT_PERL_CORE}/bin",
                        "ln -sf ${VC3_ROOT_PERL_CORE}/lib",
                        "ln -sf ${VC3_ROOT_PERL_CORE}/local_modules",
                        "ln -sf ${VC3_ROOT_PERL_CORE}/man"
                    ]
                }
            ],
            "dependencies":{
                "perl-local-lib":[
                    "v2.000019"
                ],
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-core":[
        {
            "version":"v5.24.0",
            "versioncmd":"perl -e 'print qq($^V)'",
            "versionreg":"(v[0-9.]*)",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "perl-5.24.0.tar.gz"
                    ],
                    "recipe":[
                        "CFLAGS='-m64 -mtune=nocona' ./Configure -Dprefix=${VC3_PREFIX} -des -A ccflags=-fPIC make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/local_modules"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"VC3_MODULES_PERL", 
                    "value":"${VC3_ROOT_PERL_CORE}/local_modules",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PERL5LIB",
                    "value":"${VC3_MODULES_PERL}/lib/perl5",
                    "absolute":1
                },
                {
                    "name":"PERL5LIB",
                    "value":"lib/perl5/site_perl/5.24.0"
                },
                {
                    "name":"PERL_MB_OPT", 
                    "value":"--install_base ${VC3_MODULES_PERL}",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PERL_MM_OPT", 
                    "value":"INSTALL_BASE=${VC3_MODULES_PERL}",
                    "clobber":1,
                    "absolute":1 
                },
                {
                    "name":"PATH",
                    "value":"${VC3_MODULES_PERL}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "perl-local-lib":[
        {
            "version":"v2.000019",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "local-lib-2.000019.tar.gz"
                    ],
                    "recipe":[
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "perl-core":[
                    "v5.10"
                ]
            }
        }
    ],

    "perl-cpanminus":[
        {
            "version":"v1.7",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "cpanminus-1.7.distribution"
                    ],
                    "recipe":[
                        "chmod 755 cpanminus-1.7.distribution",
                        "cp cpanminus-1.7.distribution ${VC3_MODULES_PERL}/bin/cpanm"
                    ]
                }
            ],
            "dependencies":{
                "perl-local-lib":[
                    "v2.0"
                ]
            }
        }
    ],

    "python-setuptools":[
        {
            "version":"v24.0.2",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "setuptools-24.0.2.tar.gz"
                    ],
                    "recipe":[
                        "python setup.py install --prefix=${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.6"
                ]
            },
            "environment_variables":[
                {
                    "name":"VC3_MODULES_PYTHON",
                    "value":"${VC3_ROOT_PYTHON}/local_modules",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PYTHONPATH",
                    "value":"${VC3_MODULES_PYTHON}/lib/python2.7/site-packages",
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_MODULES_PYTHON}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "python-pip":[
        {
            "version":"v1.8.2",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "pip-8.1.2.distribution"
                    ],
                    "recipe":[
                        "echo -e \"\\n[install]\\ninstall-option=--prefix=${VC3_MODULES_PYTHON}\\n\" > ${PIP_CONFIG_FILE}",
                        "python pip-8.1.2.distribution"
                    ]
                }
            ],
            "dependencies":{
                "python":[
                    "v2.6"
                ],
                "python-setuptools":[
                    "v24.0"
                ]
            },
            "environment_variables":[
                {
                    "name":"PIP_CONFIG_FILE",
                    "value":"pip.conf"
                }
            ]
        }
    ],

    "python-virtualenv":[
        {
            "version":"v0",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "pip install --user virtualenv",
                        "cd ${HOME}",
                        ".local/bin/virtualenv ${VC3_MODULES_PYTHON}"
                    ]
                }
            ],
            "start":[
                "cd ${HOME}",
                "source ${VC3_MODULES_PYTHON}/bin/activate"
            ],
            "dependencies":{
                "python-pip":[
                    "v1.8"
                ]
            },
            "environment_variables":[
                {
                    "name":"VC3_MODULES_PYTHON",
                    "value":"${VC3_ROOT_PYTHON_PIP}/local_modules",
                    "absolute":1
                }
            ]
        }
    ],

    "python":[
        {
            "version":"v2.7.12",
            "versioncmd":"python --version",
            "versionreg":"Python ([0-9.]*).*",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "python_name=$(which python2 || which python)",
                        "[ -z \"$python_name\" ] && exit 1",
                        "python_root=${python_name%/bin*}",
                        "[ -f \"$python_root\"/include/python2.7/Python.h ] || exit 1",
                        "cd ${VC3_ROOT_PYTHON}",
                        "ln -s ${python_root}/lib lib",
                        "ln -s ${python_root}/include include",
                        "mkdir bin",
                        "ln -s ${python_name} bin/python",
                        "ln -s ${python_name} bin/python2",
                        "./bin/python2 -c 'import sys; sys.version_info >= (2,6) and sys.version_info < (3,) or sys.exit(1)'"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "Python-2.7.12.tgz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install",
                        "ln -s ${VC3_PREFIX}/bin/pydoc{,2}"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"PYTHONPATH",
                    "value":"lib/python2.7/site-packages"
                }
            ]
        }
    ],

    "zlib": [
        {
            "version":"v1.2.8",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --static",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "gsl": [
        {
            "version":"v2.1",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "gsl-2.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --disable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "gettext": [
        {
            "version":"v0.19.8",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "gettext-0.19.8.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"PKG_CONFIG_PATH",
                    "value":"lib/pkgconfig"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "cxx11": [
        {
            "version":"v4.9.2",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                       "crossx86-x86_64-linux-musl-1.1.6.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_CXX11}",
                        "tar -C ${VC3_ROOT_CXX11} --strip-components=1 -xpf crossx86-x86_64-linux-musl-1.1.6.tar.gz",
                        "cd ${VC3_ROOT_CXX11}/bin; for exe in x86_64-linux-musl-*; do short=${exe#x86_64-linux-musl-}; ln -sf ${exe} ${short}; done"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "mash": [
        {
            "version":"v1.1",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                       "mash-Linux64-v1.1.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_MASH}",
                        "tar -C ${VC3_ROOT_MASH} --strip-components=1 -xpf mash-Linux64-v1.1.tar.gz"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_MASH}",
                    "absolute":1
                }
            ]
        }
    ],


    "xrootd": [
        {
            "version":"v4.3.0",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "xrootd-4.3.0.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_INSTALL_LIBDIR=lib ..",
                        "make",
                        "make install",
                        "find src -name '*.o' | xargs ar rcs ${VC3_PREFIX}/lib/libxrootd.a"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.1"
                        ]
                    }
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.10"
                ],
                "fuse":[
                    "v2.9"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "irods":[
        {
            "version":"v3.0",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "irods3.0.tgz"
                    ],
                    "recipe":[
                        "mv * ${VC3_PREFIX}",
                        "cd ${VC3_PREFIX}",
                        "./scripts/configure",
                        "make"
                    ],
                    "dependencies":{
                        "help2man":[
                            "v1.0.0"
                        ]
                    }
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"clients/icommands/bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib/core/obj"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"lib/api/include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"lib/api/include"
                }
            ]
        }
    ],

    "help2man":[
        {
            "version":"v1.43.3",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "help2man-1.43.3.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "perl-text-soundex":[
        {
            "version":"v3.0",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Text::Soundex"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-bioperl":[
        {
            "version":"v1.6",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest CJFIELDS/BioPerl-1.6.924.tar.gz"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ],
                "perl-module-build":[
                    "v0.42"
                ],
                "berkeley-db":[
                    "v6.0"
                ],
                "perl-DB_File":[
                    "v1.8"
                ]

            }
        }
    ],

    "perl-DB_File":[
        {
            "version":"v1.8",
            "sources":[
                {
                    "type":"tarball",
                    "files":["DB_File-1.838.tar.gz"],
                    "recipe":[
                        "sed -i -e 's%^INCLUDE.*%INCLUDE = '${VC3_ROOT_BERKELEY_DB}'/include%;s%^LIB.*%LIB = '${VC3_ROOT_BERKELEY_DB}'/lib%' config.in",
                        "perl Makefile.PL",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.10"
                ],
                "berkeley-db":[
                    "v6.0"
                ]
            }
        }
    ],

    "perl-dbi":[
        {
            "version":"v1.6",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest DBI"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-file-which":[
        {
            "version":"v1.2",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest File::Which"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-unsafe-signals":[
        {
            "version":"v0.03",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Perl::Unsafe::Signals"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-bit-vector":[
        {
            "version":"v7.4",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Bit::Vector"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-module-build":[
        {
            "version":"v0.4218",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Module::Build"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-inline":[
        {
            "version":"v0.8",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Inline"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-inline-c":[
        {
            "version":"v0.76",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Inline::C"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-forks":[
        {
            "version":"v0.36",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest forks"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-forks-shared":[
        {
            "version":"v0.36",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest forks"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-io-all":[
        {
            "version":"v0.86",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest IO::All"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-io-prompt":[
        {
            "version":"v0.997",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest IO::All"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-dbd-sqlite":[
        {
            "version":"v1.5",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest DBD::SQLite"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-want":[
        {
            "version":"v0.29",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest Want"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "perl-lwp-simple":[
        {
            "version":"v6.15",
            "sources":[
                {
                    "type":"generic",
                    "recipe":[
                        "cpanm --notest LWP::Simple"
                    ]
                }
            ],
            "dependencies":{
                "perl-cpanminus":[
                    "v1.7"
                ]
            }
        }
    ],

    "hmmer":[
        {
            "version":"v3.1",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "hmmer-3.1b2.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-mpi",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "openmpi":[
                    "v1.10"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "openmpi":[
        {
            "version":"v1.10",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "openmpi-1.10.3.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static --disable-shared --disable-readline",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "ncbi-blast":[
        {
            "version":"v2.2.28",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "ncbi-blast-2.2.28+-src.tar.gz"
                    ],
                    "recipe":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h",
                        ": ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-static-exe --with-static --without-caution --with-mt --with-z=${VC3_ZLIB_ROOT} --with-pcre=${VC3_PCRE_ROOT} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_SQLITE3} --without-debug",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ZLIB_ROOT} --with-pcre=${VC3_PCRE_ROOT} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_SQLITE3} --without-debug",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.2"
                ],
                "pcre":[
                    "v8.34"
                ],
                "python":[
                    "v2.6"
                ],
                "perl":[
                    "v5.8"
                ],
                "sqlite3":[
                    "v3.13"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "rmblast":[
        {
            "version":"v2.2.28",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "ncbi-rmblastn-2.2.28-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-rmblastn-2.2.28-x64-linux.tar.gz"
                    ]
                },
                {
                    "type":"tarball",
                    "files":[
                        "rmblastn-2.2.28+-src.tar.gz"
                    ],
                    "recipe":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h",
                        ": ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-static-exe --with-static --without-caution --with-mt --with-z=${VC3_ZLIB_ROOT} --with-pcre=${VC3_PCRE_ROOT} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_SQLITE3} --without-debug",
                        "./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ZLIB_ROOT} --with-pcre=${VC3_PCRE_ROOT} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_SQLITE3} --without-debug",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "zlib":[
                    "v1.2"
                ],
                "pcre":[
                    "v8.34"
                ],
                "python":[
                    "v2.6"
                ],
                "perl":[
                    "v5.8"
                ],
                "sqlite3":[
                    "v3.13"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "sqlite3":[
        {
            "version":"v3.13",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "sqlite-autoconf-3130000.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-static",
                        "make",
                        "make install"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "exonerate":[
        {
            "version":"v2.2.0",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "exonerate-2.2.0.tar.gz"
                    ],
                    "recipe":[
                        ": exonerate does not like parallel compilation",
                        "export MAKEFLAGS=-j1",
                        ": for old glibc we need to manually link librt",
                        "export LDFLAGS=-lrt",
                        "./configure --prefix ${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-glib2 --enable-utilities",
                        "make",
                        "make install"
                    ]
                }
            ],
            "dependencies":{
                "glib":[
                    "v2"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"lib"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "snap":[
        {
            "version":"v2013.11.29",
            "sources":[
                {
                    "type":"tarball",
                    "files":[
                        "snap-2013-11-29.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "cp -af ${VC3_BUILD} ${VC3_PREFIX}/snap",
                        "cd ${VC3_PREFIX}/snap",
                        "sed -i -e '678s/h2->q_end/h1->q_end/;684s/h2->s_end/h1->s_end/' Zoe/zoeAlignment.c",
                        "sed -i -e 's/-Wall//;s/-Werror//' Makefile",
                        "sed -i -e 's/-Wall//;s/-Werror//' Zoe/Makefile",
                        "make"
                    ]
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.8"
                ]
            },
            "environment_variables":[
                {
                    "name":"ZOE",
                    "value":"${VC3_ROOT_SNAP}/snap/Zoe",
                    "clobber":1,
                    "absolute":1
                },
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_SNAP}/snap",
                    "absolute":1
                }
            ]
        }
    ],

    "repeatmasker":[
        {
            "version":"v4.0.6",
            "dependencies":{
                "repeatmasker-restricted":[
                    "v4.0.6"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_REPEATMASKER}",
                    "absolute":1
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"${VC3_ROOT_REPEATMASKER}/lib",
                    "absolute":1
                }
            ]
        }
    ],

    "repeatmasker-restricted":[
        {
            "version":"v4.0.6",
            "sources":[
                {
                    "type":"manual-distribution",
                    "msg_manual_requirement":[
"RepeatMasker libraries have a restrictive distribution license, and have to",
"be downloaded manually. Please follow these steps:",
"    1) On http://www.girinst.org, click on 'Downloads'.",
"    2) Register for a free account.",
"    3) Download the most recent libray repeatmaskerlibraries-YEARMONTDAY.tar.gz.",
"    4) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/repeatmaskerlibraries-LATEST.tar.gz.",
"    For example:",
"cp ~/Downloads/repeatmaskerlibraries-20150807.tar.gz ${VC3_DISTFILES}/manual-distribution/repeatmaskerlibraries-LATEST.tar.gz",
"    5) Try again '${VC3_COMMAND_LINE}'."],
                    "files":[
                        "repeatmaskerlibraries-LATEST.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER}",
                        "tar -C ${VC3_ROOT_REPEATMASKER} -xpf repeatmaskerlibraries-LATEST.tar.gz",
                        "cd ${VC3_ROOT_REPEATMASKER}",
                        "perl VC3_RepeatMasker-open-4-0-6.configure -re_exec_perl=${VC3_ROOT_PERL}/bin/perl -repeatmasker_dir=${VC3_REPEATMASKER_ROOT} -trf_bin_path=${VC3_TRF_ROOT}/bin/trf -hmmer_bin_dir=${VC3_HMMER}/bin -rmblast_bin_dir=${VC3_RMBLAST}/bin -default_engine=rmblast"
                    ]
                }
            ],
            "dependencies":{
                "repeatmasker-free":[
                    "v4.0.6"
                ]
            }
        }
    ],

    "repeatmasker-free":[
        {
            "version":"v4.0.6",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "RepeatMasker-open-4-0-6.tar.gz",
                        "VC3_RepeatMasker-open-4-0-6.configure"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER}",
                        "tar -C ${VC3_ROOT_REPEATMASKER} --strip-components=1 -xpf RepeatMasker-open-4-0-6.tar.gz",
                        "cp VC3_RepeatMasker-open-4-0-6.configure ${VC3_ROOT_REPEATMASKER}"
                    ]
                }
            ],
            "dependencies":{
                "perl":[
                    "v5.8"
                ],
                "hmmer":[
                    "v3.1"
                ],
                "ncbi-blast":[
                    "v2.2.28"
                ],
                "rmblast":[
                    "v2.2.28"
                ],
                "trf":[
                    "v4.0.9"
                ],
                "perl-text-soundex":[
                    "v3.0"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_REPEATMASKER}",
                    "absolute":1
                },
                {
                    "name":"LD_LIBRARY_PATH",
                    "value":"${VC3_ROOT_REPEATMASKER}/lib",
                    "absolute":1
                }
            ]
        }
    ],

    "augustus":[
        {
            "version":"v2.4",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "augustus.2.4.src.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf augustus.2.4.src.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "make"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"AUGUSTUS_CONFIG_PATH",
                    "value":"config",
                    "clobber":1
                },
                {
                    "name":"PATH",
                    "value":"bin"
                },
                {
                    "name":"C_INCLUDE_PATH",
                    "value":"include"
                },
                {
                    "name":"CPLUS_INCLUDE_PATH",
                    "value":"include"
                }
            ]
        }
    ],

    "trf":[
        {
            "version":"v4.09",
            "sources":[
                {
                    "msg_manual_requirement":[
"Tandem Repeats Finder (trf) has a restrictive distribution license, and has to",
"be downloaded manually. Please follow these steps:",
"    1) On https://tandem.bu.edu/trf/trf.html, click on 'Download Your Own Copy of the Program'.",
"    2) Download the version appropiate for your machine.",
"      (Your machine is a ${VC3_MACHINE_OS}-${VC3_MACHINE_ARCH}, GLIBC version ${VC3_MACHINE_GLIBC_VERSION})",
"    3) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/trf409",
"    For example:",
"cp ~/Downloads/trf409.legacylinux64 ${VC3_DISTFILES}/manual-distribution/trf409",
"    4) Try again '${VC3_COMMAND_LINE}'."],
                    "type":"manual-distribution",
                    "files":[
                        "trf409"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        ": -L to ensure real files are copied, and not only symlinks",
                        "cp -L trf409 ${VC3_PREFIX}/bin/trf",
                        "chmod 755 ${VC3_PREFIX}/bin/trf"
                    ]
                }
            ],
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"bin"
                }
            ]
        }
    ],

    "maker":[
        {
            "version":"v2.31",
            "sources":[
                {
                    "type":"manual-distribution",
                    "msg_manual_requirement":[
"maker has a restrictive distribution license, and has to",
"be downloaded manually. Please follow these steps:",
"    1) On http://www.yandell-lab.org/software/maker.html, click on 'Registration Page'.",
"    2) Fill the form and click on 'Submit and Download MAKER.",
"    3) Download maker-2.31.8.tgz.",
"    4) Copy the file into",
"${VC3_DISTFILES}/manual-distribution/maker-2.31.8.tgz",
"    For example:",
"cp ~/Downloads/maker-2.31.8.tgz ${VC3_DISTFILES}/manual-distribution/",
"    5) Try again '${VC3_COMMAND_LINE}'."],
                    "files":[
                        "maker-2.31.8.tgz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf maker-2.31.8.tgz",
                        "cd ${VC3_PREFIX}/src",
                        ": y to activate MPI support",
                        "/bin/echo 'y' | perl Build.PL",
                        "./Build install"
                    ]
                }
            ],
            "dependencies":{
                "ncbi-blast":[
                    "v2.2.28"
                ],
                "snap":[
                    "v2013.11.29"
                ],
                "repeatmasker":[
                    "v4.0.6"
                ],
                "exonerate":[
                    "v2.2"
                ],
                "augustus":[
                    "v2.4"
                ],
                "perl-bioperl":[
                    "v1.6"
                ],
                "perl-dbi":[
                    "v1.6"
                ],
                "perl-dbd-sqlite":[
                    "v1.5"
                ],
                "perl-want":[
                    "v0.29"
                ],
                "perl-lwp-simple":[
                    "v6.15"
                ],
                "perl-file-which":[
                    "v1.2"
                ],
                "perl-unsafe-signals":[
                    "v0.03"
                ],
                "perl-bit-vector":[
                    "v7.4"
                ],
                "perl-inline":[
                    "v0.8"
                ],
                "perl-inline-c":[
                    "v0.76"
                ],
                "perl-forks":[
                    "v0.36"
                ],
                "perl-forks-shared":[
                    "v0.36"
                ],
                "perl-io-all":[
                    "v0.86"
                ],
                "perl-io-prompt":[
                    "v0.997"
                ]
            },
            "environment_variables":[
                {
                    "name":"PATH",
                    "value":"${VC3_ROOT_MAKER}/bin",
                    "absolute":1
                }
            ]
        }
    ],

    "maker-example-ecoli-01":[
        {
            "version":"v1",
            "sources":[
                {
                    "type":"generic",
                    "files":[
                        "maker-example-ecoli-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${HOME}/maker-example-ecoli-01",
                        "tar -C ${HOME}/maker-example-ecoli-01 --strip-components=1 -xpf maker-example-ecoli-01.tar.gz"
                    ]
                }
            ],
            "dependencies":
            {
                "maker":[
                    "v2.31"
                ]
            }
        }
    ]
}

